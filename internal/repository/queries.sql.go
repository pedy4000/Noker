// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package repository

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const addEvidence = `-- name: AddEvidence :exec
INSERT INTO opportunity_evidence (
    opportunity_id, meeting_id, quote, context
) VALUES ($1, $2, $3, $4)
`

type AddEvidenceParams struct {
	OpportunityID uuid.UUID      `db:"opportunity_id" json:"opportunity_id"`
	MeetingID     uuid.UUID      `db:"meeting_id" json:"meeting_id"`
	Quote         string         `db:"quote" json:"quote"`
	Context       sql.NullString `db:"context" json:"context"`
}

func (q *Queries) AddEvidence(ctx context.Context, arg AddEvidenceParams) error {
	_, err := q.db.ExecContext(ctx, addEvidence,
		arg.OpportunityID,
		arg.MeetingID,
		arg.Quote,
		arg.Context,
	)
	return err
}

const createMeeting = `-- name: CreateMeeting :one
INSERT INTO meetings (title, raw_notes, source, metadata)
VALUES ($1, $2, $3, $4)
RETURNING id, created_at
`

type CreateMeetingParams struct {
	Title    string                `db:"title" json:"title"`
	RawNotes string                `db:"raw_notes" json:"raw_notes"`
	Source   string                `db:"source" json:"source"`
	Metadata pqtype.NullRawMessage `db:"metadata" json:"metadata"`
}

type CreateMeetingRow struct {
	ID        uuid.UUID    `db:"id" json:"id"`
	CreatedAt sql.NullTime `db:"created_at" json:"created_at"`
}

// internal/repository/queries.sql
func (q *Queries) CreateMeeting(ctx context.Context, arg CreateMeetingParams) (CreateMeetingRow, error) {
	row := q.db.QueryRowContext(ctx, createMeeting,
		arg.Title,
		arg.RawNotes,
		arg.Source,
		arg.Metadata,
	)
	var i CreateMeetingRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const createOpportunity = `-- name: CreateOpportunity :one
INSERT INTO opportunities (
    user_segment, struggle, why_it_matters, workaround, theme_id
) VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_segment, struggle, why_it_matters, workaround, theme_id, created_at, updated_at
`

type CreateOpportunityParams struct {
	UserSegment  string         `db:"user_segment" json:"user_segment"`
	Struggle     string         `db:"struggle" json:"struggle"`
	WhyItMatters sql.NullString `db:"why_it_matters" json:"why_it_matters"`
	Workaround   sql.NullString `db:"workaround" json:"workaround"`
	ThemeID      uuid.NullUUID  `db:"theme_id" json:"theme_id"`
}

func (q *Queries) CreateOpportunity(ctx context.Context, arg CreateOpportunityParams) (Opportunity, error) {
	row := q.db.QueryRowContext(ctx, createOpportunity,
		arg.UserSegment,
		arg.Struggle,
		arg.WhyItMatters,
		arg.Workaround,
		arg.ThemeID,
	)
	var i Opportunity
	err := row.Scan(
		&i.ID,
		&i.UserSegment,
		&i.Struggle,
		&i.WhyItMatters,
		&i.Workaround,
		&i.ThemeID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTheme = `-- name: CreateTheme :one
INSERT INTO themes (name) VALUES ($1) RETURNING id, name, created_at
`

func (q *Queries) CreateTheme(ctx context.Context, name string) (Theme, error) {
	row := q.db.QueryRowContext(ctx, createTheme, name)
	var i Theme
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return i, err
}

const getMeeting = `-- name: GetMeeting :one
SELECT id, title, raw_notes, source, metadata, processing_status, processing_error, created_at, updated_at, processed_at FROM meetings WHERE id = $1
`

func (q *Queries) GetMeeting(ctx context.Context, id uuid.UUID) (Meeting, error) {
	row := q.db.QueryRowContext(ctx, getMeeting, id)
	var i Meeting
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.RawNotes,
		&i.Source,
		&i.Metadata,
		&i.ProcessingStatus,
		&i.ProcessingError,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProcessedAt,
	)
	return i, err
}

const getOpportunity = `-- name: GetOpportunity :one
SELECT 
    o.id, o.user_segment, o.struggle, o.why_it_matters, o.workaround, o.theme_id, o.created_at, o.updated_at,
    
    t.name AS theme_name,
    COUNT(oe.id) AS evidence_count
FROM opportunities o
LEFT JOIN themes t ON o.theme_id = t.id
LEFT JOIN opportunity_evidence oe ON oe.opportunity_id = o.id
WHERE o.id = $1
GROUP BY o.id, t.name
`

type GetOpportunityRow struct {
	ID            uuid.UUID      `db:"id" json:"id"`
	UserSegment   string         `db:"user_segment" json:"user_segment"`
	Struggle      string         `db:"struggle" json:"struggle"`
	WhyItMatters  sql.NullString `db:"why_it_matters" json:"why_it_matters"`
	Workaround    sql.NullString `db:"workaround" json:"workaround"`
	ThemeID       uuid.NullUUID  `db:"theme_id" json:"theme_id"`
	CreatedAt     sql.NullTime   `db:"created_at" json:"created_at"`
	UpdatedAt     sql.NullTime   `db:"updated_at" json:"updated_at"`
	ThemeName     sql.NullString `db:"theme_name" json:"theme_name"`
	EvidenceCount int64          `db:"evidence_count" json:"evidence_count"`
}

func (q *Queries) GetOpportunity(ctx context.Context, id uuid.UUID) (GetOpportunityRow, error) {
	row := q.db.QueryRowContext(ctx, getOpportunity, id)
	var i GetOpportunityRow
	err := row.Scan(
		&i.ID,
		&i.UserSegment,
		&i.Struggle,
		&i.WhyItMatters,
		&i.Workaround,
		&i.ThemeID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ThemeName,
		&i.EvidenceCount,
	)
	return i, err
}

const getThemeByName = `-- name: GetThemeByName :one
SELECT id, name, created_at FROM themes WHERE name = $1
`

func (q *Queries) GetThemeByName(ctx context.Context, name string) (Theme, error) {
	row := q.db.QueryRowContext(ctx, getThemeByName, name)
	var i Theme
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return i, err
}

const listAllOpportunitiesForDeduplication = `-- name: ListAllOpportunitiesForDeduplication :many
SELECT 
    o.id::text AS opportunity_id,
    o.struggle AS struggle,
    COALESCE(t.name, 'No theme') AS theme_name
FROM opportunities o
LEFT JOIN themes t ON o.theme_id = t.id
ORDER BY o.created_at DESC
`

type ListAllOpportunitiesForDeduplicationRow struct {
	OpportunityID string `db:"opportunity_id" json:"opportunity_id"`
	Struggle      string `db:"struggle" json:"struggle"`
	ThemeName     string `db:"theme_name" json:"theme_name"`
}

func (q *Queries) ListAllOpportunitiesForDeduplication(ctx context.Context) ([]ListAllOpportunitiesForDeduplicationRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllOpportunitiesForDeduplication)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllOpportunitiesForDeduplicationRow
	for rows.Next() {
		var i ListAllOpportunitiesForDeduplicationRow
		if err := rows.Scan(&i.OpportunityID, &i.Struggle, &i.ThemeName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEvidenceByOpportunity = `-- name: ListEvidenceByOpportunity :many
SELECT 
    oe.id,
    oe.quote,
    oe.context,
    oe.created_at,
    
    m.id            AS meeting_id,
    m.title         AS meeting_title,
    m.created_at    AS meeting_date,
    
    COUNT(*) OVER() AS total_count

FROM opportunity_evidence oe
JOIN meetings m ON oe.meeting_id = m.id
WHERE oe.opportunity_id = $1
ORDER BY oe.created_at DESC
`

type ListEvidenceByOpportunityRow struct {
	ID           uuid.UUID      `db:"id" json:"id"`
	Quote        string         `db:"quote" json:"quote"`
	Context      sql.NullString `db:"context" json:"context"`
	CreatedAt    sql.NullTime   `db:"created_at" json:"created_at"`
	MeetingID    uuid.UUID      `db:"meeting_id" json:"meeting_id"`
	MeetingTitle string         `db:"meeting_title" json:"meeting_title"`
	MeetingDate  sql.NullTime   `db:"meeting_date" json:"meeting_date"`
	TotalCount   int64          `db:"total_count" json:"total_count"`
}

func (q *Queries) ListEvidenceByOpportunity(ctx context.Context, opportunityID uuid.UUID) ([]ListEvidenceByOpportunityRow, error) {
	rows, err := q.db.QueryContext(ctx, listEvidenceByOpportunity, opportunityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEvidenceByOpportunityRow
	for rows.Next() {
		var i ListEvidenceByOpportunityRow
		if err := rows.Scan(
			&i.ID,
			&i.Quote,
			&i.Context,
			&i.CreatedAt,
			&i.MeetingID,
			&i.MeetingTitle,
			&i.MeetingDate,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentOpportunities = `-- name: ListRecentOpportunities :many
SELECT 
    o.id, o.user_segment, o.struggle, o.why_it_matters, o.workaround, o.theme_id, o.created_at, o.updated_at,
    t.name AS theme_name,
    COALESCE(ev_count.cnt, 0) AS evidence_count
FROM opportunities o

LEFT JOIN themes t ON o.theme_id = t.id
LEFT JOIN LATERAL (
    SELECT COUNT(*) AS cnt
    FROM opportunity_evidence oe
    WHERE oe.opportunity_id = o.id
) ev_count ON true

WHERE o.created_at >= NOW() - INTERVAL '24 hours'
ORDER BY o.created_at DESC
`

type ListRecentOpportunitiesRow struct {
	ID            uuid.UUID      `db:"id" json:"id"`
	UserSegment   string         `db:"user_segment" json:"user_segment"`
	Struggle      string         `db:"struggle" json:"struggle"`
	WhyItMatters  sql.NullString `db:"why_it_matters" json:"why_it_matters"`
	Workaround    sql.NullString `db:"workaround" json:"workaround"`
	ThemeID       uuid.NullUUID  `db:"theme_id" json:"theme_id"`
	CreatedAt     sql.NullTime   `db:"created_at" json:"created_at"`
	UpdatedAt     sql.NullTime   `db:"updated_at" json:"updated_at"`
	ThemeName     sql.NullString `db:"theme_name" json:"theme_name"`
	EvidenceCount int64          `db:"evidence_count" json:"evidence_count"`
}

func (q *Queries) ListRecentOpportunities(ctx context.Context) ([]ListRecentOpportunitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, listRecentOpportunities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecentOpportunitiesRow
	for rows.Next() {
		var i ListRecentOpportunitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserSegment,
			&i.Struggle,
			&i.WhyItMatters,
			&i.Workaround,
			&i.ThemeID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ThemeName,
			&i.EvidenceCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopOpportunitiesByTheme = `-- name: ListTopOpportunitiesByTheme :many
SELECT 
    o.id,
    o.user_segment,
    o.struggle,
    o.why_it_matters,
    o.workaround,
    o.created_at,
    COUNT(oe.id) AS evidence_count
FROM opportunities o
LEFT JOIN opportunity_evidence oe ON oe.opportunity_id = o.id
JOIN themes t ON o.theme_id = t.id
WHERE LOWER(t.name) = LOWER($1)
GROUP BY o.id, o.struggle, o.created_at
ORDER BY evidence_count DESC, o.created_at DESC
LIMIT $2
`

type ListTopOpportunitiesByThemeParams struct {
	Lower string `db:"lower" json:"lower"`
	Limit int32  `db:"limit" json:"limit"`
}

type ListTopOpportunitiesByThemeRow struct {
	ID            uuid.UUID      `db:"id" json:"id"`
	UserSegment   string         `db:"user_segment" json:"user_segment"`
	Struggle      string         `db:"struggle" json:"struggle"`
	WhyItMatters  sql.NullString `db:"why_it_matters" json:"why_it_matters"`
	Workaround    sql.NullString `db:"workaround" json:"workaround"`
	CreatedAt     sql.NullTime   `db:"created_at" json:"created_at"`
	EvidenceCount int64          `db:"evidence_count" json:"evidence_count"`
}

func (q *Queries) ListTopOpportunitiesByTheme(ctx context.Context, arg ListTopOpportunitiesByThemeParams) ([]ListTopOpportunitiesByThemeRow, error) {
	rows, err := q.db.QueryContext(ctx, listTopOpportunitiesByTheme, arg.Lower, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTopOpportunitiesByThemeRow
	for rows.Next() {
		var i ListTopOpportunitiesByThemeRow
		if err := rows.Scan(
			&i.ID,
			&i.UserSegment,
			&i.Struggle,
			&i.WhyItMatters,
			&i.Workaround,
			&i.CreatedAt,
			&i.EvidenceCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopThemesThisWeek = `-- name: ListTopThemesThisWeek :many
SELECT 
    t.name AS theme_name,
    COUNT(*) AS opportunity_count,
    -- for better ranking
    COUNT(*) + COUNT(*) FILTER (WHERE o.created_at >= NOW() - INTERVAL '3 days') AS score
FROM opportunities o
JOIN themes t ON o.theme_id = t.id
WHERE o.created_at >= date_trunc('week', CURRENT_DATE)
GROUP BY t.id, t.name
HAVING COUNT(*) >= 1
ORDER BY score DESC, opportunity_count DESC, t.name
LIMIT 10
`

type ListTopThemesThisWeekRow struct {
	ThemeName        string `db:"theme_name" json:"theme_name"`
	OpportunityCount int64  `db:"opportunity_count" json:"opportunity_count"`
	Score            int32  `db:"score" json:"score"`
}

func (q *Queries) ListTopThemesThisWeek(ctx context.Context) ([]ListTopThemesThisWeekRow, error) {
	rows, err := q.db.QueryContext(ctx, listTopThemesThisWeek)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTopThemesThisWeekRow
	for rows.Next() {
		var i ListTopThemesThisWeekRow
		if err := rows.Scan(&i.ThemeName, &i.OpportunityCount, &i.Score); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMeetingStatus = `-- name: UpdateMeetingStatus :exec
UPDATE meetings
SET 
  processing_status = $2,
  processing_error = CASE 
    WHEN $3::text = '' THEN NULL 
    ELSE $3 
  END,
  processed_at = CASE 
    WHEN $2 = 'done' OR $2 = 'failed' THEN NOW()
    ELSE processed_at 
  END
WHERE id = $1
`

type UpdateMeetingStatusParams struct {
	ID               uuid.UUID `db:"id" json:"id"`
	ProcessingStatus string    `db:"processing_status" json:"processing_status"`
	Column3          string    `db:"column_3" json:"column_3"`
}

func (q *Queries) UpdateMeetingStatus(ctx context.Context, arg UpdateMeetingStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateMeetingStatus, arg.ID, arg.ProcessingStatus, arg.Column3)
	return err
}
